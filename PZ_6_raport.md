# Делала Диана Волощук из ИС-25
# Задание 1
Дано целое число больше 2. Сформировать и вывести список из первых 10 чисел Фибоначи.
# Алгоритм
Создаем функцию gen_fib_num. Присваиваем переменной N число 10. Создаем список fib из 2 значений. for i in range(2, N) - спосок будет просматриваться в диапазоне от 2 до N-1. fib.append(fib[i-2] + fib[i-1]) - добавляет в конец списка fib элемент, равный выражению в скобках: предыдущий элемент плюс последний. Возвращаем значение fib. Выводим функцию. 
# Объяснение кода
def - создает функцию. N = 10 - переменная равна 10. fib = [1, 1] - список включает в себя два значения.  for i in range(2, N) - цикл пройдётся по всем числам от 2 до N-1. fib.append(fib[i-2] + fib[i-1]) - добавляет в конец списка новый элемент. return fib - возвращаем список fib. print (gen_fib_num()) - выводим функцию print gen_fib_num.

# Задание 2
Дан список A размера N и целые числа K и L (1 < K < L < N). Переставить в обратном порядке элементы списка, расположенные между элементами Ak u Al, включая эти элементы.
# Алгоритм
Создаем функцию reverse с атрибутами A, K и L. Если условие выполняется (1 < K < L < N), то мы переворачиваем элементы списка в указанном диапазоне и возвращаем измененный список. Присваиваем переменной А список. Просим ввести целочисленные числа для определения диапазона K и L. Выводим функцию. 
# Объяснение кода
def - создает функцию. if 1 < K < L < len(A): - если Длинная списка А больше L, K  и одного, то -> A[K-1:L] = A[K-1:L][::-1] Операция [::-1] означает, что нужно рассмотреть элементы списка от первого к последнему, но в обратном порядке. A[K-1:L] - Срез позволяет выбрать часть списка A от K-1 до L-1. return A - возвращает список А. A = [1, 2, 3, 4, 5, 6, 7, 8, 9] - спосок А. int(input() - возврвщает целочисленные числа. print - выводит список.
# Задание 3
Дан список размера N. Обнулить все его локальные максимумы.
# Алгоритм
Создаем функцию, которая удаляет локальные максимумы из списка arr. Если список пустой, то возвращаем пустой список. В переменную n возвращаем длинну массива. Возвращаем копию массива. Проверяем каждый элемент списка на локальные максимумы. Проверяем, является ли элемент локальным максимумом, и если нет, нетрогаем его. Если элемент локальный максумум, то удаляем его из списка. Возвращаем список без локальных максимумов. Просим пользователя ввести размер списка. Просим ввести элементы списка через пробел. Выводим исходный список и список после удаления локальных максимумов.
# Объяснение кода
def remove_local_maximum(arr) - функция, которая удаляет локальные максимумы из списка arr. if not arr - если список отсутствует, то return arr возвращаем пустой список. n = len(arr) - возвращает в переменную количество элементов списка arr. arr.copy() - возвращает копию списка. for i in range(n): - проверяем каждый элемент списка.   if i > 0 and arr[i] <= arr[i-1]: - проверяем, является ли элемент локальным максимумом. is_local_maximum = False - не трогаем элемент, если он не максимум. if i < n - 1 and arr [i] <= arr[i+1]: - проверяем, является ли элемент локальным максимумом.  if is_local_maximum: - если элемент локальный максумум, то удаляем его из списка - result[i] = 0. return result - возвращаем список без локальных максимумов. int(input()) - ввод целочисленной переменной. split() преобразует строку в список по разделителю. map преобразует список в соответствие с функцией — в данном случае int(). list(...) - преобразует результат map() в список с использованием функции list().
